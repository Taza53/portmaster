// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.2
// source: plugins.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// PluginManagerServiceClient is the client API for PluginManagerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PluginManagerServiceClient interface {
	ListPlugins(ctx context.Context, in *ListPluginsRequest, opts ...grpc.CallOption) (*ListPluginsResponse, error)
	RegisterPlugin(ctx context.Context, in *RegisterPluginRequest, opts ...grpc.CallOption) (*RegisterPluginResponse, error)
	UnregisterPlugin(ctx context.Context, in *UnregisterPluginRequest, opts ...grpc.CallOption) (*UnregisterPluginResponse, error)
	StopPlugin(ctx context.Context, in *StopPluginRequest, opts ...grpc.CallOption) (*StopPluginResponse, error)
	StartPlugin(ctx context.Context, in *StartPluginRequest, opts ...grpc.CallOption) (*StartPluginResponse, error)
}

type pluginManagerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPluginManagerServiceClient(cc grpc.ClientConnInterface) PluginManagerServiceClient {
	return &pluginManagerServiceClient{cc}
}

func (c *pluginManagerServiceClient) ListPlugins(ctx context.Context, in *ListPluginsRequest, opts ...grpc.CallOption) (*ListPluginsResponse, error) {
	out := new(ListPluginsResponse)
	err := c.cc.Invoke(ctx, "/safing.portmaster.plugin.proto.PluginManagerService/ListPlugins", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginManagerServiceClient) RegisterPlugin(ctx context.Context, in *RegisterPluginRequest, opts ...grpc.CallOption) (*RegisterPluginResponse, error) {
	out := new(RegisterPluginResponse)
	err := c.cc.Invoke(ctx, "/safing.portmaster.plugin.proto.PluginManagerService/RegisterPlugin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginManagerServiceClient) UnregisterPlugin(ctx context.Context, in *UnregisterPluginRequest, opts ...grpc.CallOption) (*UnregisterPluginResponse, error) {
	out := new(UnregisterPluginResponse)
	err := c.cc.Invoke(ctx, "/safing.portmaster.plugin.proto.PluginManagerService/UnregisterPlugin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginManagerServiceClient) StopPlugin(ctx context.Context, in *StopPluginRequest, opts ...grpc.CallOption) (*StopPluginResponse, error) {
	out := new(StopPluginResponse)
	err := c.cc.Invoke(ctx, "/safing.portmaster.plugin.proto.PluginManagerService/StopPlugin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginManagerServiceClient) StartPlugin(ctx context.Context, in *StartPluginRequest, opts ...grpc.CallOption) (*StartPluginResponse, error) {
	out := new(StartPluginResponse)
	err := c.cc.Invoke(ctx, "/safing.portmaster.plugin.proto.PluginManagerService/StartPlugin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PluginManagerServiceServer is the server API for PluginManagerService service.
// All implementations must embed UnimplementedPluginManagerServiceServer
// for forward compatibility
type PluginManagerServiceServer interface {
	ListPlugins(context.Context, *ListPluginsRequest) (*ListPluginsResponse, error)
	RegisterPlugin(context.Context, *RegisterPluginRequest) (*RegisterPluginResponse, error)
	UnregisterPlugin(context.Context, *UnregisterPluginRequest) (*UnregisterPluginResponse, error)
	StopPlugin(context.Context, *StopPluginRequest) (*StopPluginResponse, error)
	StartPlugin(context.Context, *StartPluginRequest) (*StartPluginResponse, error)
	mustEmbedUnimplementedPluginManagerServiceServer()
}

// UnimplementedPluginManagerServiceServer must be embedded to have forward compatible implementations.
type UnimplementedPluginManagerServiceServer struct {
}

func (UnimplementedPluginManagerServiceServer) ListPlugins(context.Context, *ListPluginsRequest) (*ListPluginsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPlugins not implemented")
}
func (UnimplementedPluginManagerServiceServer) RegisterPlugin(context.Context, *RegisterPluginRequest) (*RegisterPluginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterPlugin not implemented")
}
func (UnimplementedPluginManagerServiceServer) UnregisterPlugin(context.Context, *UnregisterPluginRequest) (*UnregisterPluginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnregisterPlugin not implemented")
}
func (UnimplementedPluginManagerServiceServer) StopPlugin(context.Context, *StopPluginRequest) (*StopPluginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopPlugin not implemented")
}
func (UnimplementedPluginManagerServiceServer) StartPlugin(context.Context, *StartPluginRequest) (*StartPluginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartPlugin not implemented")
}
func (UnimplementedPluginManagerServiceServer) mustEmbedUnimplementedPluginManagerServiceServer() {}

// UnsafePluginManagerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PluginManagerServiceServer will
// result in compilation errors.
type UnsafePluginManagerServiceServer interface {
	mustEmbedUnimplementedPluginManagerServiceServer()
}

func RegisterPluginManagerServiceServer(s grpc.ServiceRegistrar, srv PluginManagerServiceServer) {
	s.RegisterService(&PluginManagerService_ServiceDesc, srv)
}

func _PluginManagerService_ListPlugins_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPluginsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginManagerServiceServer).ListPlugins(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/safing.portmaster.plugin.proto.PluginManagerService/ListPlugins",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginManagerServiceServer).ListPlugins(ctx, req.(*ListPluginsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginManagerService_RegisterPlugin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterPluginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginManagerServiceServer).RegisterPlugin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/safing.portmaster.plugin.proto.PluginManagerService/RegisterPlugin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginManagerServiceServer).RegisterPlugin(ctx, req.(*RegisterPluginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginManagerService_UnregisterPlugin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnregisterPluginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginManagerServiceServer).UnregisterPlugin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/safing.portmaster.plugin.proto.PluginManagerService/UnregisterPlugin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginManagerServiceServer).UnregisterPlugin(ctx, req.(*UnregisterPluginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginManagerService_StopPlugin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopPluginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginManagerServiceServer).StopPlugin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/safing.portmaster.plugin.proto.PluginManagerService/StopPlugin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginManagerServiceServer).StopPlugin(ctx, req.(*StopPluginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginManagerService_StartPlugin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartPluginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginManagerServiceServer).StartPlugin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/safing.portmaster.plugin.proto.PluginManagerService/StartPlugin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginManagerServiceServer).StartPlugin(ctx, req.(*StartPluginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PluginManagerService_ServiceDesc is the grpc.ServiceDesc for PluginManagerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PluginManagerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "safing.portmaster.plugin.proto.PluginManagerService",
	HandlerType: (*PluginManagerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListPlugins",
			Handler:    _PluginManagerService_ListPlugins_Handler,
		},
		{
			MethodName: "RegisterPlugin",
			Handler:    _PluginManagerService_RegisterPlugin_Handler,
		},
		{
			MethodName: "UnregisterPlugin",
			Handler:    _PluginManagerService_UnregisterPlugin_Handler,
		},
		{
			MethodName: "StopPlugin",
			Handler:    _PluginManagerService_StopPlugin_Handler,
		},
		{
			MethodName: "StartPlugin",
			Handler:    _PluginManagerService_StartPlugin_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "plugins.proto",
}
